/********************************************************************************************************
Copyright: wuyong
Author: wuyong
Date: 2018-05-16
Description:本例程提供了C++的STL常用数据结构及其算法的使用范例，为面试笔试编程题提供便利
*********************************************************************************************************/

#include <iostream>  
/*************************************************顺序容器***********************************************/
#include <string> //和vector是一样的，支持快速随机访问，在尾部之外的其他的位置插入都很慢
#include <vector> //可变大小数组，支持快速随机访问，在尾部之外的其它位置插入或者删除元素可能很慢

#include <list>   //双向链表，只支持双向顺序访问，在list中的任意位置插入和删除都很快

//forward_list单向链表设计目标是达到与手写单向链表相当的性能。
#include <forward_list>  //单向链表，只支持单向顺序访问，在链表任意位置插入和删除都很快,是c++11新加的标准

//在queue的中间位置插入或者删除元素代价都很高
#include <deque>  //双端队列，支持快速随机访问（肯定是顺序存储式队列），从头尾位置处插入和删除速度很快

//与内置数组相比，更加安全和方便；
#include <array>  //固定数组大小，支持快速，不能添加或者删除元素，是c++11新加的标准
/*************************************************顺序容器***********************************************/

/*************************************************关联容器***********************************************/
#include <map> 
/*************************************************关联容器***********************************************/


/*************************************************无序容器***********************************************/

/*************************************************无序容器***********************************************/

/*-----------------------------------------------------------------------------------------------------------
选择顺序容器的准则：
1）若要求支持随机访问,vector queue
2）程序要求在中间插入或者删除元素，则选择使用list 或者forward_list
3）如果程序只会在头部或者尾部插入删除数据，则选择使用queue
4）如果不知道选择哪种容器，则在程序中只使用list和vector容器，并且只使用迭代器而不使用下标操作
-----------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------
容器所共同支持的操作：
1）类型别名
	1. iterator/const_iterator/size_type/difference_type/reference/const_reference

2）构造函数
	1. C c         //调用默认构造函数，无参
	2. C c1(c2)    //调用复制构造函数，有参，可合成
	3. C c(b, e)   //调用构造函数，带参，迭代器b,e指向的容器范围进行初始化构造
	4. C c{a, b, c, ......} //列表初始化构造，带参构造

3）赋值与swap
	c1 = c2
	c1 = {a, b, c, ......}
	a.swap(b)   //成员函数版的交换函数
	swap(a, b)  //非成员函数版的交换函数

4）大小
	1. c.size()   //求容器大小，
	2. c.max_size() //容器最多可保存的数据
	3. c.empty() //返回容器是否为空

5）添加删除元素
	1. c.insert(args)  //插入元素
	2. c.emplace(inits)  //使用inits构造c中的一个元素
	3. c.erase(args)    //删除元素

6）获取迭代器
	1. c.bengin() c.end()
	2. c.cbegin(), c.cend()
	反向迭代器的成员
	reverse_iterator
	const_reverse_interator
	3. c.rbegin(), c.rend()
	4. c.crbegin(), c.crend()
-----------------------------------------------------------------------------------------------------------*/

















